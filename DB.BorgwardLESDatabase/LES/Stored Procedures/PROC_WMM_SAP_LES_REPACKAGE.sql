



CREATE PROCEDURE [LES].[PROC_WMM_SAP_LES_REPACKAGE]
AS
DECLARE @ID BIGINT;--通知单ID
DECLARE @WERKS nvarchar(4);--工厂模型_工厂
DECLARE @LGORT nvarchar(4);--库存地点
DECLARE @LGPBE nvarchar(14);--存贮区编码
DECLARE @FBTYPE nvarchar(1);--翻包类型
DECLARE @LGMNG numeric(18,3);--数量
DECLARE @BUDAT VARCHAR(8);--计划翻包日期
DECLARE @TIMS VARCHAR(6);--计划翻包时间
DECLARE @CPUTM DATETIME;--发布日期
DECLARE @MATNR nvarchar(18);--零件号
DECLARE @MAKTX_ZH nvarchar(40);--零件名称
DECLARE @R_MENGE numeric(18,3);--翻包数量
DECLARE @ZXBQJC nvarchar(20);--上线包装型号
DECLARE @ZXBQJQ numeric(18,3);--上线包装数量
DECLARE @ZYSQJC nvarchar(20);--入厂包装型号
DECLARE @BSTRF numeric(18,3);--入厂包装数量
DECLARE @L_MENGE numeric(18,3);--翻包本地剩余数
DECLARE @ZFBLJ nvarchar(30);--翻包路径

DECLARE @REPACKAGE_ENDTIME DATETIME;  --翻包完成时间
DECLARE @REPACKAGE_PARAMETER INT;     --翻包完成延时时间

--根据配置获取翻包完成延时时间
SELECT   @REPACKAGE_PARAMETER = ISNULL(PARAMETER_VALUE,0)
FROM      LES.TS_SYS_CONFIG
where parameter_name = 'RepackageEndTime'


DECLARE REPACKAGE_CURS  CURSOR FOR
	select DISTINCT ID,
	WERKS,
	LGORT,
	FBTYPE,
	BUDAT,
	TIMS,
	ZFBLJ  
	FROM Les.TI_WMS_REPACKAGE_PLANS 
	WHERE ISNULL(PROCESS_FLAG,0)=0 
	ORDER by ID
OPEN REPACKAGE_CURS
FETCH NEXT FROM REPACKAGE_CURS INTO @ID,@WERKS,@LGORT,@FBTYPE,@BUDAT,@TIMS,@ZFBLJ
WHILE( @@fetch_status = 0 )
BEGIN
	
		DECLARE @REPACKAGE_TIME DATETIME;--计划翻包时间
		IF(ISNULL(@BUDAT,'00000000')='00000000' OR @BUDAT='')
		BEGIN
			SET @REPACKAGE_TIME=NULL;
		END
        ELSE
        BEGIN	
			--PRINT 	@BUDAT+' '+substring(@TIMS,1,2)+':'+ substring(@TIMS,3,2)+':'+substring(@TIMS,5,2)		
			SELECT @REPACKAGE_TIME=CONVERT(datetime,@BUDAT+' '+substring(@TIMS,1,2)+':'+ substring(@TIMS,3,2)+':'+substring(@TIMS,5,2))
			--计算翻包完成时间
			SET @REPACKAGE_ENDTIME = DATEADD(mi,@REPACKAGE_PARAMETER,@REPACKAGE_TIME);
		END;

		DECLARE @REPACKAGE_ID BIGINT;
		SET @REPACKAGE_ID=-1

		--插入翻包计划主表,并获取最新id
		SELECT TOP 1 @REPACKAGE_ID=REPACKAGE_ID FROM LES.TT_WMM_REPACKAGE_HEAD 
			WHERE REPACKAGE_NO= CAST( @ID as nvarchar(50)) --盘点凭证
			AND PLANT=@WERKS --工厂代码
			AND ZONE_NO=@LGORT --库存地点
		--return @REPACKAGE_ID
		IF(@REPACKAGE_ID=-1)--在翻包计划表中不存在主表记录
		BEGIN

			INSERT INTO LES.TT_WMM_REPACKAGE_HEAD(REPACKAGE_NO,PLANT,WM_NO,ZONE_NO,REPACKAGE_TYPE,BOOK_KEEPER,PLANT_ZONE,
			REPACKAGE_TIME,REPACKAGE_BTIME,REPACKAGE_ETIME,CREATE_DATE,CREATE_USER,COUNT_STATUS,REPACKAGE_ROUTE)
			select @ID,@WERKS,WM_NO,@LGORT,@FBTYPE,'admin',@LGORT,@REPACKAGE_TIME,@REPACKAGE_TIME,@REPACKAGE_ENDTIME,GETDATE(),'admin',0,@ZFBLJ
			FROM LES.TM_WMM_ZONES WHERE ZONE_NO=@LGORT AND PLANT=@WERKS	

			SELECT @REPACKAGE_ID=SCOPE_IDENTITY();
			
			--根据主表id和库存记录,插入详细表
			--张恒更改 之前倒入 有部分数据写反 同时有部分数据据未赋值
			INSERT INTO LES.TT_WMM_REPACKAGE_DETAIL(
			REPACKAGE_ID,
			REPACKAGE_NO,
			PART_NO,
			PART_CNAME,
			ZONE_NO,
			NUM,
			INHOUSE_PACKAGE_MODEL,
			INHOUSE_PACKAGE,
			INBOUND_PACKAGE_MODEL,
			INBOUND_PACKAGE,
			PACKAGE_MODEL,
			PACKAGE,
			Wm_No,
			uloc,
			CREATE_DATE,
			CREATE_USER,
			REQUIRED_QTY)
			SELECT 
			@REPACKAGE_ID,
			t_plans.ID,
			t_plans.MATNR,
			t_plans.MAKTX_ZH,
			t_plans.LGORT,
			t_plans.R_MENGE,
			t_plans.ZXBQJC,
			t_plans.ZXBQJQ,
			t_plans.ZYSQJC,
			t_plans.BSTRF,
			t_plans.ZYSQJC,
			t_plans.BSTRF,
			t_zones.WM_NO,
			t_stock.DLOC,
			GETDATE(),
			'admin',
			(t_plans.R_MENGE*t_plans.BSTRF)
			 FROM Les.TI_WMS_REPACKAGE_PLANS t_plans
			 INNER JOIN LES.TM_WMM_ZONES t_zones
				ON t_plans.LGORT=t_zones.ZONE_NO
			 INNER join [LES].TM_BAS_PARTS_STOCK t_stock
				on t_stock.PART_NO = t_plans.MATNR and t_stock.WM_NO=t_zones.WM_NO and t_stock.ZONE_NO=t_plans.LGORT
			WHERE ID=@ID and ISNULL(t_plans.PROCESS_FLAG,0)=0 
		END
        ELSE
		BEGIN
			--根据主表id和库存记录,插入详细表
			--INSERT INTO TT_WMM_REPACKAGE_DETAIL(REPACKAGE_ID,REPACKAGE_NO,PART_NO,PART_CNAME,ZONE_NO,NUM,PACKAGE,
			--INHOUSE_PACKAGE_MODEL,INHOUSE_PACKAGE,INBOUND_PACKAGE_MODEL,Wm_No)
			--SELECT @REPACKAGE_ID,t_plans.ID,t_plans.MATNR,t_plans.MAKTX_ZH,
			--t_plans.LGORT,t_plans.R_MENGE,t_plans.BSTRF,t_plans.ZYSQJC,t_plans.ZXBQJQ,t_plans.ZXBQJC,t_zones.WM_NO
			-- FROM Les.TI_WMS_REPACKAGE_PLANS t_plans
			-- INNER JOIN LES.TM_WMM_ZONES t_zones
			--	ON t_plans.LGORT=t_zones.ZONE_NO
			--WHERE t_plans.ID=@ID and ISNULL(t_plans.PROCESS_FLAG,0)=0 
			--AND t_plans.MATNR NOT IN (SELECT part_no FROM TT_WMM_REPACKAGE_DETAIL WHERE REPACKAGE_ID=@REPACKAGE_ID)
			--张恒更改 之前倒入 有部分数据写反 同时有部分数据据未赋值
			INSERT INTO LES.TT_WMM_REPACKAGE_DETAIL(REPACKAGE_ID,REPACKAGE_NO,PART_NO,PART_CNAME,ZONE_NO,NUM
			,INHOUSE_PACKAGE_MODEL,INHOUSE_PACKAGE,INBOUND_PACKAGE_MODEL,INBOUND_PACKAGE,PACKAGE_MODEL,PACKAGE
			,Wm_No,uloc,CREATE_DATE,CREATE_USER,
			REQUIRED_QTY)
			SELECT @REPACKAGE_ID,t_plans.ID,t_plans.MATNR,t_plans.MAKTX_ZH,t_plans.LGORT,t_plans.R_MENGE
			,t_plans.ZXBQJC,t_plans.ZXBQJQ,t_plans.ZYSQJC,t_plans.BSTRF,t_plans.ZYSQJC,t_plans.BSTRF
			,t_zones.WM_NO,t_stock.DLOC,GETDATE(),'admin',
			(t_plans.R_MENGE*t_plans.BSTRF)
				FROM Les.TI_WMS_REPACKAGE_PLANS t_plans
				INNER JOIN LES.TM_WMM_ZONES t_zones
				ON t_plans.LGORT=t_zones.ZONE_NO
				INNER join [LES].TM_BAS_PARTS_STOCK t_stock
				on t_stock.PART_NO = t_plans.MATNR and t_stock.WM_NO=t_zones.WM_NO and t_stock.ZONE_NO=t_plans.LGORT
			WHERE t_plans.ID=@ID and ISNULL(t_plans.PROCESS_FLAG,0)=0 
			AND t_plans.MATNR NOT IN (SELECT part_no FROM TT_WMM_REPACKAGE_DETAIL WHERE REPACKAGE_ID=@REPACKAGE_ID)
		END;

		UPDATE t_plans SET PROCESS_FLAG=1,PROCESS_TIME=GETDATE() FROM Les.TI_WMS_REPACKAGE_PLANS t_plans
			 INNER JOIN LES.TM_WMM_ZONES t_zones
				ON t_plans.LGORT=t_zones.ZONE_NO
				WHERE t_plans.ID=@ID
				 
FETCH NEXT FROM REPACKAGE_CURS INTO @ID,@WERKS,@LGORT,@FBTYPE,@BUDAT,@TIMS,@ZFBLJ
END
CLOSE  REPACKAGE_CURS
DEALLOCATE REPACKAGE_CURS