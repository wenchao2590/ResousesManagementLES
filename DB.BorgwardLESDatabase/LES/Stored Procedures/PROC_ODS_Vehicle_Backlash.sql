

CREATE PROCEDURE [LES].[PROC_ODS_Vehicle_Backlash]

    --(
     --@PLANT NVARCHAR(5) ,
     --@ASSEMBLY_LINE NVARCHAR(10) ,
      --@ORDER_ID NVARCHAR(20) ,
      --@ZONE NVARCHAR(10)
    --)
--AS

AS
	DECLARE @PLANT NVARCHAR(5)
	DECLARE @ASSEMBLY_LINE NVARCHAR(10)
	DECLARE @ORDER_ID NVARCHAR(20)
	DECLARE @ZONE NVARCHAR(10)


BEGIN
	SET NOCOUNT ON
	SET XACT_ABORT ON

	BEGIN
		BEGIN TRAN
		--计算该流水线下的车辆零件消耗，直接扣减库存信息
		UPDATE A
		SET A.[STOCKS_NUM] = A.[STOCKS_NUM] - B.[QUANTITY],
			A.[STOCKS] = CAST((ISNULL(A.STOCKS_NUM, 0) - ISNULL(B.[QUANTITY], 0)) AS INT) / ISNULL(A.PACKAGE, 1),
			A.[FRAGMENT_NUM] = CAST((ISNULL(A.STOCKS_NUM, 0) - ISNULL(B.[QUANTITY], 0)) AS INT) % ISNULL(A.PACKAGE, 1),
			A.[AVAILBLE_STOCKS] = CAST((ISNULL(A.STOCKS_NUM, 0) - ISNULL(B.[QUANTITY], 0) - ISNULL(A.[FROZEN_STOCKS], 0)) AS INT) / ISNULL(A.PACKAGE, 1),
			A.[UPDATE_DATE] = GETDATE()
		FROM [LES].[TT_WMS_STOCKS] A WITH (ROWLOCK)
		INNER JOIN [LES].[TT_BAS_ORDER_PART_RESULTS] B WITH (NOLOCK) ON B.[PLANT] = A.[PLANT] AND B.[PART_NO] = A.[PART_NO] AND B.[ORDER_NO] = @ORDER_ID
		WHERE A.[PLANT] = @PLANT 
		AND A.[ZONE_NO] = @ZONE
		AND B.[LOCATION] IN (SELECT [ZLOC] FROM [LES].[TI_BAS_PART_LACATION_IN] WITH (NOLOCK) WHERE [ZKWERK] = @PLANT AND [ZWS] = @ASSEMBLY_LINE)  --根据零件工位信息找出该流水线下的所有工位
		AND A.[STOCK_IDENTITY] IN (SELECT MIN([STOCK_IDENTITY]) FROM [LES].[TT_WMS_STOCKS] WITH (NOLOCK) WHERE [PLANT] = @PLANT AND [ZONE_NO] = @ZONE AND ([BARCODE_DATA] IS NULL OR [BARCODE_DATA] = '') GROUP BY [PLANT], [ZONE_NO], [PART_NO]) --获取库存中零件最小的ID号
	
		--更新扫描点对应的车辆处理状态
		UPDATE [LES].[TT_ODS_BACKLASH_POINT] WITH (ROWLOCK)
		SET [PROCESS_FLAG] = 1,
			[UPDATE_DATE] = GETDATE()
		WHERE [PLANT] = @PLANT AND [ASSEMBLY_LINE] = @ASSEMBLY_LINE AND [ORDER_ID] = @ORDER_ID

		COMMIT TRAN
	END
END